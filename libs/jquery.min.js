/ *! jQuery v3.5.0 -ajax, -ajax / jsonp, -ajax / load, -ajax / script, -ajax / var / location, -ajax / var / nonce, -ajax / var / rquery, -ajax / xhr, -манипуляция / _evalUrl, -deprecated / ajax-event-alias, -effects, -effects / Tween, -effects / animatedSelector | (c) Фонд JS и другие участники | jquery.org/license * /
! function (e, t) {"использовать строгий"; "объект" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) выбросить новую ошибку («jQuery требует окно с документом»); return t (e)}: t (e)} («undefined»! = typeof window? window: this, function ( g, e) {"использовать строгий"; var t = [], r = Object.getPrototypeOf, s = t.slice, v = t.flat? function (e) {return t.flat.call (e)}: function (e) {return t.concat.apply ([], e)}, u = t.push, i = t.indexOf, n = {}, o = n.toString, y = n.hasOwnProperty, a = y.toString, l = a.call (Object), m = {}, b = function (e) {return "function" == typeof e && "number"! = typeof e.nodeType}, x = function (e) {return null! = e && e === e.window}, w = g.document, c = {type:! 0, src:! 0, nonce:! 0, noModule:! 0}; функция C (e, t , n) {var r, i, o = (n = n || w) .createElement ("script");if (o.text = e, t) для (r в c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o ) .parentNode.removeChild (o)} function T (e) {return null == e? e + "": "object" == typeof e || "function" == typeof e? n [o.call (e) ] || "объект": typeof e} var f = "3.5.0 -ajax, -ajax / jsonp, -ajax / load, -ajax / script, -ajax / var / location, -ajax / var / nonce, - ajax / var / rquery, -ajax / xhr, -manipulation / _evalUrl, -deprecated / ajax-псевдоним события, -effects, -effects / Tween, -effects / animatedSelector ", E = function (e, t) {вернуть новое E.fn.init (e, t)}; функция d (e) {var t = !! e && "длина" в e && e.length, n = T (e); вернуть! B (e) &&! X (e ) && ("массив" === n || 0 === t || "число" == typeof t && 0 <t && t-1 в e)} E.fn = E.prototype = {jquery: f, конструктор: E , длина: 0, ToArray:function () {return s.call (this)}, get: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e] }, pushStack: function (e) {var t = E.merge (this.constructor (), e); return t.prevObject = this, t}, каждый: function (e) {return E.each (this, e )}, map: function (n) {вернуть this.pushStack (E.map (this, function (e, t) {вернуть n.call (e, t, e)}))}, slice: function () { return this.pushStack (s.apply (this, arguments))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, even: function () {return this.pushStack (E.grep (this, function (e, t) {return (t + 1)% 2}))}, нечетное: function () {return this.pushStack (E.grep (this , function (e, t) {return t% 2}))}, eq: function (e) {var t = this.length, n = + e + (e <0? t: 0); вернуть this.pushStack ( 0 <= n && n <t? [This [n]]: [])}, end: function () {return this.prevObject || this.constructor ()}, push: u, sort: t.sort, splice: t.splice}, E.extend = E.fn.extend = function () {var e, t, n, r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; для («логическое») == typeof a && (l = a, a = arguments [s] || {}, s ++), "объект" == typeof a || b (a) || (a = {}), s === u && (a = this, s -); s <u; s ++) if (null! = (e = arguments [s])) для (t in e) r = e [t], "__proto__"! == t && a ! == г && (л && && г (E.isPlainObject (г) || (я = Array.isArray (г))) (п = а [т], о = я && Array.isArray (п) []:?!? я || E.isPlainObject (n)? N: {}, i =! 1, a [t] = E.extend (l, o, r)): void 0! == r && (a [t] = r) ); вернуть a}, E.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, ошибка: function (e) {throw new Error (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[объект объекта]"! == o.call (e )) && (! (т = г (е)) || "функции" == TypeOf (п = y.call (т, "конструктор") && t.constructor) && a.call (n) === l)}, isEmptyObject: function (e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e, t, n) {C (e, {nonce: t && t.nonce}, n)}, каждый: function (e, t) {var n, r = 0; if (d (e)) {for (n = e.length ; r <n; r ++) if (! 1 === t.call (e [r], r, e [r])) break} иначе для (r in e) if (! 1 === t.call (e [r], r, e [r])) break; return e}, makeArray: function (e, t) {var n = t || []; return null! = e && (d (Object (e) )? E.merge (n, "строка" == typeof e? [E]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null = = t? -1: i.call (t, e, n)}, merge: function (e, t) {for (var n = + t.length, r = 0, i = e.length; r <n ; r ++) e [i ++] = t [r]; возвращаем e.length = i, e}, grep: function (e, t, n) {for (var r = [], i = 0, o = e. длина, a =! n; i <o; i ++)! t (e [i], i)! == a && r.push (e [i]); return r}, map: function (e, t, n) {var r, i, o = 0, a = []; если (d (e)) для (r = e.length; o <r; o ++) null! = (i = t (e [o], o , п)) && a.push (я);иначе для (o in e) null! = (i = t (e [o], o, n)) && a.push (i); return v (a)}, guid: 1, support: m}), " function "== typeof Symbol && (E.fn [Symbol.iterator] = t [Symbol.iterator]), E.each (" Булево число Строка Функция Массив Дата Символ ошибки объекта RegExp ".split (" "), function (e , t) {n ["[object" + t + "]"] = t.toLowerCase ()}); var p = function (n) {var e, p, x, o, i, h, f, g, w, u, l, C, T, a, E, v, s, c, y, A = "шипение" + 1 * новая дата, d = n.документ, N = 0, r = 0, m = ue (), b = ue (), S = ue (), k = ue (), D = function (e, t) {return e === t && (l =! 0), 0}, L = {} .hasOwnProperty, t = [], j = t.pop, q = t.push, O = t.push, P = t.slice, H = function (e, t) {для (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, I = "проверено | выбрано | асинхронно | автофокус | автозапуск | управление | отложить | отключено | отключено | скрыто | ISMAP | петля | кратно | открыт | только для чтения | требуется | область действия»R = "[\\ x20 \\ т \\ г \\ п \\ е]",В = "(?: \\\\ [\\ да-FA-F] {1,6}"? + R + "| \\\\ [^ \\ г \\ п \\ е] | [\\ w-] | [^ \ 0 - \\ x7f]) + "М = "\\ [" + R + "* (" + B + ") (?:" + R +" * ([* ^ $ | ~! ] =) "+ R +" *? (: '((?:. \\\\ | [^ \\\\'?]) *) '| \ "((?:. \\\\ | [^ \\\\\ "]) *) \" | ( "+ B +")) |) "+ R +" * \\] "W = ":(" + B +") (: \\ (((? '((?:. \\\\ | [^ \\\\']) *) '| \ "((?:. \\\\ | [^ \\\\\"]) *) \» ) | ((?: \\\\. | [^ \\\\ () [\\]] | "+ M +") *) |. *) \\) |) ", F = new RegExp (R + "+", "g"), $ = new RegExp ("^" + R + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + R + "+ $", "g"), z = новый RegExp ("^" + R + "*," + R + "*"), _ = новый RegExp ("^" + R + "* ([> + ~] | "+ R +") "+ R +" * "), U = новый RegExp (R +" |> "), V = новый RegExp (W), X = новый RegExp (" ^ "+ B +"$ "), Q = {ID: новый RegExp (" ^ # ("+ B +") "), КЛАСС: новый RegExp (" ^ \\. ("+ B +") "), TAG: новый RegExp (" ^ ("+ B +" | [*]) "), ATTR: новый RegExp (" ^ "+ M), PSEUDO: новый RegExp (" ^ "+ W), РЕБЕНОК: новый RegExp (" ^ :( только | первый | первый | последняя | энный | п-й последний) - (ребенок | из-типа) (?: \\ ( "+ R +" * (даже | нечетный | (([+ -] |) (\\ d *) п |)» + R + "* (?: ([+ -] |)" + R + "* (\\ d +) |))" + R + "* \\) |)", "i"), bool: new RegExp (" ^ (?: "+ I +") $ "," i "), needsContext: new RegExp (" ^ "+ R +" * [> + ~] |: (четный | нечетный | eq | gt | lt | nth | первый | последний)? (?? \\ ( "+ R +" * ((: - \\ d) \\ d *) "+ R +" * \\) |) (= [^ -] | $)» , "я")}, Y = / html $ I, G = ^ (?: вход / / | выбрать | текстовое поле | кнопка) $ / I, K = / ^ ч \ д $ / I, J = / ^ [ ^ {] + \ {\ s * \ [native \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\\\ [\\ да-FA-F] {1,6} "+ R +" |? \\\\ ([^ \\ г \\ п \\ е])», "г"), пе = function (e, t) {var n = "0x" + e.slice (1) -65536; вернуть t || (n <0? String.fromCharCode (n + 65536): String.fromCharCode (n >> 10) | 55296,1023 & п | 56320))}, п = / ([\ 0- \ x1f \ x7f] | ^ - \ г) |? ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w- ] / g, т.е. = function (e, t) {return t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e .length-1) .toString (16) + "": "\\" + e}, oe = function () {C ()}, ae = xe (function (e) {return! 0 === e. инвалидов && "FIELDSET" === e.nodeName.toLowerCase ()}, {реж: "ParentNode", следующая: "легенда"}); попытка {O.apply (т = P.call (d.childNodes), д. ChildNodes), т [d.childNodes.length] .nodeType} поймать (е) {O = {применяется: t.length функции (е, т) {q.apply (е, P.call (т))}: function (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} функция se (t, e, n,r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, d = e? e.nodeType: 9; if (n = n || [], "string"! = typeof t ||! t || 1! == d && 9! == d && 11! == d) вернуть n; if (! r && (C (e), e = e || T, E)) {if (11! = = d && (u = Z.exec (t))) if (i = u [1]) {if (9 === d) {if (! (a = e.getElementById (i))) вернуть n; если (a.id === i) вернуть n.push (a), n} иначе, если (f && (a = f.getElementById (i)) && y (e, a) && a.id === i) вернуть n. push (a), n} else {if (u [2]) return O.apply (n, e.getElementsByTagName (t)), n; if ((i = u [3]) && p.getElementsByClassName && e.getElementsByClassName) return O.apply (n, e.getElementsByClassName (i)), n} if (p.qsa &&! K [t + ""] && (! V ||! V.test (t)) && (1! == d | |! "объект" == e.nodeName.toLowerCase ())) {если (с = т, е = е, 1 === д && (U.test (т) || _.test (т))) { (е = ee.test (т) && вы (e.parentNode) || е) === е && p.scope || ((с = е.? GetAttribute ( "ID")) с = s.replace (п, т):. E.setAttribute ( "Идентификатор", с = А)), O = (L = Н (Т)) длины, в то время (о- -) l [o] = (s? "#" + s: ": scope") + "" + be (l [o]); c = l.join (",")} try {return O.apply (n, f.querySelectorAll (c)), n} catch (e) {k (t,! 0)} finally {s === A && e.removeAttribute ("id")}}} return g (t.replace ( $, "$ 1"), e, n, r)} function ue () {var r = []; вернуть функцию e (t, n) {return r.push (t + "")> x.cacheLength && delete e [r .shift ()], e [t + ""] = n}} функция le (e) {вернуть e [A] =! 0, e} функция ce (e) {var t = T.createElement ("fieldset") ; try {return !! e (t)} catch (e) {return! 1} finally {t.parentNode && t.parentNode.removeChild (t), t = null}} функция fe (e, t) {var n = e .split ("|"), r = n.length; while (r -) x.attrHandle [n [r]] = t} функция de (e, t) {var n = t && e, r = n && 1 == = е.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) возвращает r; if (n), а (n = n.nextSibling) if (n === t) return-1; возвращает e? 1: -1} function pe (t) {return function (e) {return «input» === e.nodeName.toLowerCase () && e.type === t}} function he (n) {return function (e) { var t = e.nodeName.toLowerCase (); return ("input" === t || "button" === t) && e.type === n}} function ge (t) {return function (e) {вернуть "форму" в e? e.parentNode &&! 1 === e.disabled? "label" в e? "label" в e.parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) === t: e.disabled === t: "метка" в e && e.disabled === t}} функции ve (a) {return le (function (o) {return o = + o, le (function (e, t) {var n, r = a ([], e.length, o), i = r.length; в то время как (я -) е [п = г [г]] && (е [п] =!(t [n] = e [n]))})})} функция ye (e) {вернуть e && "undefined"! = typeof e.getElementsByTagName && e} для (e in p = se.support = {}, i = se.isXML = function (e) {var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement; вернуть! Y.test (t || n && n.nodeName || "HTML")}, C = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: d; return r! = T && 9 === r.nodeType && r.documentElement && (a = (T = r). documentElement, Е = я (Т), г = Т && (п = T.defaultView) && n.top == п && (n.addEventListener n.addEventListener ( "выгрузить", ае, 1):!!!?! n.attachEvent && п .attachEvent ("onunload", oe)), p.scope = ce (function (e) {return a.appendChild (e) .appendChild (T.createElement ("div")), "undefined"! = typeof e. querySelectorAll &&! e.querySelectorAll (": scope fieldset div"). length}), с.attribute = ce (function (e) {return e.className = "i",! e.getAttribute ("className")}), p.getElementsByTagName = ce (function (e) {вернуть e.appendChild (T.createComment ( "")) ,! e.getElementsByTagName ("*"). length}), p.getElementsByClassName = J.test (T.getElementsByClassName), p.getById = ce (function (e) {вернуть a.appendChild (e) .id = A,! T.getElementsByName ||! T.getElementsByName (A) .length}), p.getById? (x.filter.ID = function (e) {var t = e.replace (te, ne) ; return function (e) {return e.getAttribute ("id") === t}}, x.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n = t.getElementById (e); вернуть n? [n]: []}}) :( x.filter.ID = function (e) {var n = e.replace (te, ne); вернуть функцию (e ) {var t = "undefined"! = typeof e.getAttributeNode && e.getAttributeNode ("id"); вернуть t && t.value === n}}, x.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ( "ID")) && n.value === е) возвращение [о]; I = t.getElementsByName (е), г = 0, в то время (о = я [г ++]), если ((п = о .getAttributeNode ( "ID")) && n.value === е) возвращение [о]} возвращение []}}), x.find.TAG = p.getElementsByTagName? функция (е, т) {возвращение "неопределенными"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): p.qsa? t.querySelectorAll (e): void 0}: функция (e, t) {var n, r = [], i = 0, o = t .getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, x.find. CLASS = p.getElementsByClassName && function (e, t) {if ("undefined"! = Typeof t.getElementsByClassName && E) return t.getElementsByClassName (e)}, s = [], v = [], (p.qsa = J.test (T.querySelectorAll)) &&(ce (function (e) {var t; a.appendChild (e) .innerHTML = "<a id='"+A+"'> </a> <select id = '" + A + "- \ r \\ 'msallowcapture =' '> <option selected =' '> </ option> </ select> ", e.querySelectorAll (" [msallowcapture ^ =' '] "). length && v.push (" [* ^ $] = " + R + "* (?: '' | \" \ ")"), e.querySelectorAll ( "[выбран]") длина || v.push ( "\\ [" + R + "* (?: значение. | "+ I +") "), e.querySelectorAll (" [ID = ~ "+ A +" -] ") длина || v.push (" ~ = "), (т = T.createElement (" вход ") ) .setAttribute ( "название", ""), e.appendChild (т), e.querySelectorAll ( "[имя = '']"). длина || v.push ( "\\ [" + R + "* имя "+ R +" = "+ R +" * (?: '' | \ "\") "), E.querySelectorAll (": проверен ") длина || v.push (.": Проверен "), e.querySelectorAll (" A # "+ A +" + * ") || длина v.push (". . #. + [+ ~] "), e.querySelectorAll (" \\\ ф "), v.push (" [\\ г \\ п \\ е] ")}), CE (функция (е) {e.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </ select>"; var t = T.createElement ("input" ); t.setAttribute ( "тип", "скрытый"), e.appendChild (т) .setAttribute ( "название", "d"), e.querySelectorAll ( "[имя = d]") длина && v.push (. !. "имя" + R + "? * [! * ^ $ | ~] ="), 2 == e.querySelectorAll ( ": включено") длина && v.push ( ": включено", ": отключено"), A .appendChild (е) .disabled = 0,2 == e.querySelectorAll ( "!:отключено ") Длина && v.push (": включено " ": отключено"), e.querySelectorAll ( "* ,: х"), v.push (" *: ").})), (p.matchesSelector = J.test (с = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && се (функция (е) {p.disconnectedMatch = c.call (е,» * "), c.call (e," [s! = '']: x "), s.push ("! = ", W)}), v = v.length && new RegExp (v.join (" | ")), s = s.length && new RegExp (s.join (" | ")), t = J.test (a.compareDocumentPosition), y = t || J.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; вернуть e === r ||! (! r || 1! == r.nodeType ||! (? n.contains n.contains (г): e.compareDocumentPosition && 16 & e.compareDocumentPosition (г)))}: функция (е, т) {если (т), а (т = t.parentNode), если (т е === ) возвращение 0!;return! 1}, D = t? function (e, t) {if (e === t) return l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; return n || ( 1 & (п = (e.ownerDocument || е) == (t.ownerDocument || т) e.compareDocumentPosition (т): 1)!? || p.sortDetached && t.compareDocumentPosition (е) === п е = = Т || e.ownerDocument == д && у (д, е) - 1:?? Т == Т || t.ownerDocument == д && у (д, т) 1: и Н (и, е) -H ( u, t): 0: 4 & n? -1: 1)}: функция (e, t) {if (e === t) return l =! 0,0; var n, r = 0, i = e. parentNode, o = t.parentNode, a = [e], s = [t]; если (! i ||! o) вернуть e == T? -1: t == T? 1: i? -1: o? 1: u? H (u, e) -H (u, t): 0; если (i === o) вернуть de (e, t); n = e; while (n = n.parentNode) a.unshift (n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [r]) r ++; вернуть r? de (a [r ], s [r]): a [r] == d? -1: s [r] == d? 1: 0}), T}, se.matches = function (e, t) {return se ( e, null, null, t)}, se.matchesSelector = function (e, t) {if (C (e), p.matchesSelector && E &&! k [t + ""] && (! s ||! s.test (t)) && (! v ||! v.test (t))) try {var n = c.call (e, t); if (n || p. disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (e) {k (t,! 0)} return 0 <se (t, T, null, [e]). length}, se.contains = функция (е, т) {возвращение (e.ownerDocument || е)! = Т && С (е), у (е, т)}, se.attr = функция (е, т) {(e.ownerDocument || e)! = T && C (e); var n = x.attrHandle [t.toLowerCase ()], r = n && L.call (x.attrHandle, t.toLowerCase ())? n (e, t,! E ): void 0; вернуть void 0! == r? r: p.attributes ||! E? e.getAttribute (t) :( r = e.getAttributeNode (t)) && r.specified? r.value: null} , se.escape = function (e) {return (e + ""). replace (re, ie)}, se.error = function (e) {throw new Error ("Синтаксическая ошибка, нераспознанное выражение:" + e)} , se.uniqueSort = function (e) {var t, n = [], r = 0, i = 0; if (l =! p.detectDuplicates, u =! p.sortStable && e.slice (0), e.sort (D)л) {в то время как (т = е [я ++]) === т е [I] && (г = n.push (я)), тогда как (г -) e.splice (п [г], 1)} return u = null, e}, o = se.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i | | 9 === i || 11 === i) {if ("string" == typeof e.textContent) вернуть e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else, если (3 === i || 4 === i) вернуть e.nodeValue} else, в то время как (t = e [r ++]) n + = o (t); вернуть n}, (x = se.selectors = {cacheLength: 50, createPseudo: le, match: Q, attrHandle: {}, find: {}, относительный: {">": {dir: "parentNode", first:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", first:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = E [1] .Надеть (т, п), е [3] = (е [3] || е [4] || е [5] || ""). заменить (т, п) , "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, РЕБЕНОК: функция (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (e ? [3] || se.error (е [0]), е [4] = + (е [4] е [5] + (е [6] || 1): 2 * ( "даже" == = е [3] || "нечетные" === е [3])), е [5] = + (е [7] + е [8] || "нечетный" === е [3])) : e [3] && se.error (e [0]), e}, PSEUDO: function (e) {var t, n =! e [6] && e [2]; вернуть Q.CHILD.test (e [0 ?]) нуль: (? е [3] е [2] = е [4] || е [5] || "": п && V.test (п) && (! т = ч (п, 0)) && (т = n.indexOf ( ")", n.length-т) -n.length) && (е [0] = е [0] .slice (0, т), е [2] = n.slice ( 0, t)), e.slice (0,3))}}, фильтр: {TAG: function (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" == = e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e) {var t = m [e + ""] ; вернуть t || (t = new RegExp ("(^ |" + R + ")" + e + "(" + R + "| $)")) && m (e, function (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "") })}, ATTR: function (n, r, i) {вернуть функцию (e) {var t = se.attr (e, n); вернуть null == t? "! =" === r:! R || (т + = "", "=" === г т === я: "=" === г т == я?! "!? ^ =" === г я && 0 === t.indexOf (я): "* =" === г я && - 1 <t.indexOf (я):? "$ =" === г я && t.slice (-i.length) === я: "~ =" === r? -1 <("" + + t.replace (F, "") + "") .indexOf (i): "| =" === r && (t === i | | t.slice (0, i.length + 1) === i + "-"))}}, РЕБЕНОК: функция (h, e, t, g, v) {var y = "nth"! == h .slice (0,3), m = "last"! == h.slice (-4), b = "of-type" === e; return 1 === g &&0 === v? Function (e) {return !! e.parentNode}: function (e, t, n) {var r, i, o, a, s, u, l = y! == m? " NextSibling ":" PreviousSibling», с = e.parentNode, е = Ь && e.nodeName.toLowerCase (в), г = п && Ь, р = 1, если (с) {если (у) {в то время как (л) {!!! а = е, тогда как (A = A [L]), если (б a.nodeName.toLowerCase () === е: 1 === a.nodeType) возвращение 1; U = L = "только" ==! ! = ч && у && "NextSibling"} возвращает 0}, если (и = [м c.firstChild: c.lastChild], м && д)! {р = (s = (г = (г = (о = (а = с) [А] || (а [А] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] || []) [0] === N && г [ 1]) && г [2], A = s && c.childNodes [с], в то время (а = ++ с && && а [л] || (р = s = 0) || u.pop ()), если (1 === a.nodeType && ++ p && a === e) {i [h] = [N, s, p]; break}} иначе, если (d && (p = s = (r = (i = (o = (a = e) ) [А] || (а [А] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] || []) [0] === N && г [1]) ,! 1 === р), а (а = ++ s && &&а [л] || (р = S = 0) || u.pop ()), если ((б a.nodeName.toLowerCase () === е: 1 === a.nodeType) && ++ р && (d && ((я = (о = [А] || (а [А] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] = [N , р]), A === е)) перерыва; возвращение (р = у) === г || р% г == 0 && 0 <= р / г}}}, пСЕВДО: функция (е, о) {var t, a = x.pseudos [e] || x.setFilters [e.toLowerCase ()] || se.error ("неподдерживаемое псевдо:" + e); вернуть [A]? a (o): 1 <a.length? (T = [e, e, "", o], x.setFilters.hasOwnProperty (e.toLowerCase ())? Le (function (e, t) {var n, r = a (e , о), I = r.length, в то время (я -) е [п = Н (е, г [г])] = (т [п] = г [г])}): функция (е) {return a (e, 0, t)}): a}}, псевдо: {not: le (function (e) {var r = [], i = [], s = f (e.replace ($, «$ 1»)); вернуть s [A]? Le (функция (e, t, n, r) {var i, o = s (e, null, r, []), a = e.length; while ( a -) (i = o [a]) && (e [a] =! (t [a] = i))}): function (e, t, n) {return r [0] = e, s ! (г, нуль, п, я), г [0] = NULL, i.pop ()}}), имеет:le (function (t) {return function (e) {return 0 <se (t, e) .length}}), содержит: le (function (t) {return t = t.replace (te, ne), function (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (function (n) {return X.test (n || "") || se.error ("неподдерживаемый lang:" + n), n = n.replace (te, ne) .toLowerCase (), function (e) {var t; do {if (t = E? e.lang: e. GetAttribute ( "XML: Lang") || e.getAttribute ( "языки")) возвращение (т = t.toLowerCase ()) === п || 0 === t.indexOf (п + "-")}, а ((e = e.parentNode) && 1 === e.nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) = == e.id}, root: function (e) {return e === a}, focus: function (e) {return e === T.activeElement && (! T.hasFocus || T.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, включено: ge (! 1), отключено: ge (! 0), проверено: function (e) {var t = e.nodeName ,toLowerCase (); вернуть «input» === t && !! e.checked || «option» === t && !! e.selected}, selected: function (e) {return e.parentNode && e.parentNode.selectedIndex ,! 0 === e.selected}, опустошить:! функцию (е) {для (е = e.firstChild, е, е = e.nextSibling), если (e.nodeType <6) возвращает 1; возврат 0}, родитель : function (e) {return! x.pseudos.empty (e)}, заголовок: function (e) {return K.test (e.nodeName)}, вход: function (e) {вернуть G.test (e. имя_узла)}, кнопка: function (e) {var t = e.nodeName.toLowerCase (); вернуть "input" === t && "button" === e.type || "button" === t}, text: function (e) {var t; вернуть «input» === e.nodeName.toLowerCase () && «text» === e.type && (null == (t = e.getAttribute ("type")) || "текст" === t.toLowerCase ())}, во-первых: ве (функция () {возвращение [0]}), последнее: ве (функция (е, т) {возвращение [т-1]}) , эк: ве (функция (е,t, n) {return [n <0? n + t: n]}), четное: ve (функция (e, t) {for (var n = 0; n <t; n + = 2) e.push ( n); вернуть e}), нечетное: ve (функция (e, t) {for (var n = 1; n <t; n + = 2) e.push (n); вернуть e}), lt: ve ( function (e, t, n) {for (var r = n <0? n + t: t <n? t: n; 0 <= - r;) e.push (r); вернуть e}), gt: ve (функция (e, t, n) {for (var r = n <0? n + t: n; ++ r <t;) e.push (r); вернуть e})}}). pseudos.nth = x.pseudos.eq, {радио: 0, флажок: 0, файл: 0, пароль: 0, изображение: 0!!!}) x.pseudos [е] = ре (е), для (e в {submit:! 0, сброс:! 0}) x.pseudos [e] = he (e); function me () {} функция be (e) {для (var t = 0, n = e. length, r = ""; t <n; t ++) r + = e [t] .value; return r} функция xe (s, e, t) {var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, d = r ++; вернуть функцию e.first? (e, t, n) {while (e = e [u]) if (1 === e .nodeType || f) return s (e, t, n); return! 1}: функция (e, t, n) {var r, i, o, a = [N, d]; if (n) { в то время как (е = е [и]), если ((1 === e.nodeType || е) && с (е, т, п)) возвращение!0} else while (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [A] || (e [A] = {})) [e .uniqueID] || (о [e.uniqueID] = {}), л && л === e.nodeName.toLowerCase ()) е = е [и] || е, иначе {если ((г = я [с] ) && r [0] === N && r [1] === d) вернуть a [2] = r [2]; if ((i [c] = a) [2] = s (e, t, n) ) return! 0} return! 1}} функция we (i) {return 1 <i.length? function (e, t, n) {var r = i.length; while (r -) if (! i [] r] (e, t, n)) return! 1; return! 0}: i [0]} функция Ce (e, t, n, r, i) {для (var o, a = [], s = 0, и = e.length, л = NULL = т;! з <и; s ++), (! о = е [с]) && (п && п (о, г, я) || (a.push (о) , l && t.push (s))); вернуть функцию} Te (p, h, g, v, y, e) {вернуть v &&! v [A] && (v = Te (v)), y &&! y [ A] && (y = Te (y, e)), le (функция (e, t, n, r) {var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) {для (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); вернуть n} (h || "*", n.nodeType [N]: N, []), е = р || х && ч с:?!? С (с, с, р, п, г), д = г у | ? | (е р:л || v) []: т: е; если (г && г (е, д, п, г), v) {I = Ce (д, и), V (я, [], п, г), о = i.length, в то время (о -) (а = я [о]) && (д [и [о]] = (е [и [о]] = а)!)}, если (е) {если (у || р) {если (у) {я = [], о = D.Length, в то время (о -) (а = д [о]) && i.push (е [о] = а); у (нуль, д = [], I, R)} о = D.Length, в то время (о -) (а = д [о]) && - 1 <(я = у Н (е, а): с? [o]) && (e [i] =! (t [i] = a))}} иначе d = Ce (d === t? d.splice (l, d.length): d), y? y (null, t, d, r): O.apply (t, d)})} функция Ee (e) {для (var i, t, n, r = e.length, o = x.relative [e [0] .type], a = o || x.relative [""], s = o? 1: 0, u = xe (function (e) {return e === i}, a,! 0) , l = xe (function (e) {return-1 <H (i, e)}, a,! 0), c = [function (e, t, n) {var r =! o && (n || t ! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n)); вернуть i = null, r}]; s <r; s ++) если (т = x.relative [е [с] .type]) с = [х (мы (с), т)], иначе {если ((т = x.filter [е [с] .type] .Нанесите (null, e [s] .matches)) [A]) {for (n = ++ s; n <r; n ++) if (x.relative [e [n] .type]) break; вернуть Te (1 <s && we (c), 1 <s && be (e.slice (0, s-1) .concat ({value: "" === e [s-2] .type? "*": ""})). replace ($ "$ 1"), t, s <п && Ee (e.slice (s, N)), п <г && Ee (е = e.slice (п)), п <г && быть (е))} c.push ( t)} return we (c)} return me.prototype = x.filters = x.pseudos, x.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i, o , a, s, u, l = b [e + ""]; если (l) вернуть t? 0: l.slice (0); a = e, s = [], u = x.preFilter; while (a ) {for (o в n &&! (r = z.exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push (i = []) ), n =! 1, (r = _. exec (a)) && (n = r.shift (), i.push ({значение: n, тип: r [0] .replace ($, "")) }), а = a.slice (n.length)), x.filter)! (г = Q [о] .exec (а)) || и [о] &&! (г = и [о] (г )) || (п = r.shift (), i.push ({значение: п, тип: о, совпадения: г}!), а = a.slice (n.length)); если (п) перерыв } return t? a.length: a? se.error (e): b (e, s) .slice (0)}, f = se.compile = function (e,t) {var n, v, y, m, b, r, i = [], o = [], a = S [e + ""]; if (! a) {t || (t = h (e )), п = t.length; при этом (п -) (а = Ee (т [п])) [А] i.push (а): o.push (а); (а = S (е? , (v = o, m = 0 <(y = i). длина, b = 0 <v.length, r = функция (e, t, n, r, i) {var o, a, s, u = 0, L = "0", с = е && [], F = [], д = ш, р = е || б && x.find.TAG ( "*", I), ч = N + = NULL == д? 1:! Math.random () || 0,1, г = p.length, ибо (я && (ш = Т == Т || т || I), л == г && нуль = (о = р [л] ), л ++) {если (б && о) {а = 0, т || o.ownerDocument == Т || (С (о), п = Е);!, а (с = v [A ++]), если (ы ( о, т || Т, п))! {r.push (о); перерыв} я && (N = H)} м && ((о = ы && о) && и -, е && c.push (о))}, если (и + = л, м && л == и) {а = 0;!, а (с = у [A ++]) с (в, е, т, п), если (е) {если (0 <и) в то время как (L-- ) с [л] || е [л] || (е [л] = j.call (г));! F = С (е)} O.apply (г, е), я && е && 0 <f.length && 1 <u + y.length && se.uniqueSort (r)} return i && (N = h, w = d), c}, m? le (r): r))).selector = e} return a}, g = se.select = function (e, t, n, r) {var i, o, a, s, u, l = "function" == typeof e && e, c =! r && h (е = l.selector || е); если (п = п || [], 1 === c.length) {если (2 <(о = с [0] = с [0] .slice (0 )). длина && "ИД" === (а = о [0]). тип && 9 === t.nodeType && Е && x.relative [о [1] .type]) {если (! (т = (x.find.ID (a.matches [0] .replace (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift () .value.length)} I = Q.needsContext.test (е) 0: o.length, в то время (я -) {если (а = о [I], x.relative [с = a.type])? перерыв; если ((и = x.find [с]) && (г = и (a.matches [0] .Надеть (т, п), ee.test (о [0] .type) && (t.parentNode у ^ ) || t))) {if (o.splice (i, 1),! (e = r.length && be (o))) return O.apply (n, r), n; break}}} return (l || е (е, с)) (г, т,! е, п,! т || ee.test (е) && вы (t.parentNode) || т), п}, p.sortStable = A.split ( "") .sort (D) .join ( "") === А, стр.detectDuplicates = !! l, C (), p.sortDetached = ce (function (e) {return 1 & e.compareDocumentPosition (T.createElement ("fieldset"))}), ce (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || fe ("тип | href | высота | ширина", функция (e , t, n) {if (! n) вернуть e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)}), p.attributes && ce (function (e) {return e.innerHTML = "<ввода />", e.firstChild.setAttribute ( "значение", "") "" === e.firstChild.getAttribute ( "значение")}) || Fe ( "значение", функция (е , t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue}), ce (function (e) {return null == e.getAttribute ("disabled") }) || fe (I, функция (e, t, n) {var r; if (! n) возвращает! 0 === e [t]? t.toLowerCase () :( г = e.getAttributeNode (т)) && r.specified r.value: NULL}), как таковые} (г); E.find = р, E.expr = p.selectors, E.expr [ ":"] = E.expr.pseudos, E.uniqueSort = E.unique = p.uniqueSort, E.text = p.getText, E.isXMLDoc = p.isXML, E.contains = p.contains, E.escapeSelector = p.escape; var h = function (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType) {if (i && E (e) .is (n)) break; r.push (e)} return r}, A = function (e, t) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, N = E.expr.match.needsContext; функция S (e, t) { return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var k = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; функция D (e, n, r) {return b (n)? E. grep (e, function (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? E.grep (e, function (e) {return e == ! = п == г}):"string"! = typeof n? E.grep (e, function (e) {return-1 <i.call (n, e)! == r}): E.filter (n, e, r)} E .filter = function (e, t, n) {var r = t [0]; вернуть n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType ? E.find.matchesSelector (r, e)? [R]: []: E.find.matches (e, E.grep (t, function (e) {return 1 === e.nodeType}))} , E.fn.extend ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = Typeof e) возвращает this.pushStack (E (e). фильтр (функция () {для (т = 0; т <г, Т ++), если (E.contains (я [т], это)) возврат 0!})), для (п = this.pushStack ([]) , t = 0; t <r; t ++) E.find (e, i [t], n); return 1 <r? E.uniqueSort (n): n}, filter: function (e) {вернуть это. pushStack (D (this, e || [] ,! 1))}, а не: function (e) {вернуть this.pushStack (D (this, e || [] ,! 0))}, есть: function ( e) {return !! D (this, "string" == typeof e && N.test (e)? E (e): e || [] ,! 1) .length}}); var L, j = / ^ (?: \ S * (<[\ ш \ W] +>) [^>] * | # ([\ w -] +)) $ /; (E.fn.init = function (e, t, n) {var r, i; if (! e) вернуть это; if (n = n || L, "string" == typeof e) {if (! (r = "<" === e [0] && ">" === e [e.length-1] && 3 < ? = e.length [нуль, е, нулевая]:! j.exec (е)) || г [1] && г) возвращение т || t.jquery (т || п) .find (е): this.constructor (t) .find (e); if (r [1]) {if (t = t instanceof E? t [0]: t, E.merge (this, E.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: w,! 0)), k.test (r [1]) && E.isPlainObject (t)) для (r в t) b (this [r])? this [ r] (t [r]): this.attr (r, t [r]); вернуть this} return (i = w.getElementById (r [2])) && (this [0] = i, this.length = 1) this} return e.nodeType? (This [0] = e, this.length = 1, this): b (e)? Void 0! == n.ready? N.ready (e): e (E): E.makeArray (e, this)}). Prototype = E.fn, L = E (w); var q = / ^ (?: Родители | пред (?: До | Все)) /, O = {children:! 0, содержимое:! 0, следующее:! 0, prev:! 0}; функция P (e,t) {while ((e = e [t]) && 1! == e.nodeType); return e} E.fn.extend ({has: function (e) {var t = E (e, this), n = t.length; вернуть this.filter (function () {for (var e = 0; e <n; e ++) if (E.contains (this, t [e])) return! 0})}, ближайший: function (e, t) {var n, r = 0, i = this.length, o = [], a = "string"! = typeof e && E (e); if (! N.test (e)) для ( ; г <I, R ++), для (п = это [г]; п && п == т; п = n.parentNode), если (n.nodeType <11 && (-1 <a.index (N):? 1 = == n.nodeType && E.find.matchesSelector (n, e))) {o.push (n); break} вернуть this.pushStack (1 <o.length? E.uniqueSort (o): o)}, индекс: function (e) {return e? "string" == typeof e? i.call (E (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? This.first (). PrevAll (). Length: -1}, add: function (e, t) {вернуть this.pushStack (E.uniqueSort (E.merge (this. get (), E (e, t))))}, addBack: function (e) {вернуть this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), E.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t.nodeType? t: null}, родители: function (e) {return h (e, "parentNode")}, parentUntil: function (e, t, n) {return h (e, "parentNode", n)}, следующий: function (e) {return P ( e, "nextSibling")}, prev: function (e) {return P (e, "previousSibling")}, nextAll: function (e) {return h (e, "nextSibling")}, prevAll: function (e) {return h (e, "previousSibling")}, nextUntil: function (e, t, n) {return h (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return h ( e, "previousSibling", n)}, братья и сестры: function (e) {return A ((e.parentNode || {}). firstChild, e)}, дети: function (e) {return A (e.firstChild) }, содержимое: function (e) {return null! = e.contentDocument && r (e.contentDocument)? e.contentDocument: (S (e, "template") && (e = e.content || e), E.merge ([], e.childNodes))}}, функция (r, i) {E.fn [r] = функция (e, t) {var n = E.map (this, i, e); вернуть "До"! == r.slice (-5) && (t = e), t && "string" == typeof t && (n = E.filter (t, n)), 1 <this.length && (O [r] || E.uniqueSort (n), q.test (r) && n.reverse ()), this.pushStack (n)}}); var H = / [^ \ x20 \ t \ r \ n \ f] + / g; функция I (e) {return e} функция R (e) {throw e} функция B (e, t, n, r) {var i; попробовать {е && B (I = e.promise) i.call (е) .done (т) .fail (п): е && Ь (I = e.then) i.call (е, т, п): т. apply (void 0, [e] .slice (r))} catch (e) {n.apply (void 0, [e])}} E.Callbacks = function (r) {var e, n; r = " строка "== typeof r? (e = r, n = {}, E.each (e.match (H) || [], функция (e, t) {n [t] =! 0}), n ): E.extend ({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () {для (a = a || r .once, о = = 0;! u.length; л = -1) {т = u.shift (), в то время (++ л <s.length) 1 === s [L] .Нанесите (! т [0], т [1]) && R.stopOnFalse && (л = s.length, т = 1!)} R.memory || (т = 1!), Г = 1, а && (S = T []:? "")!}, F = { add: function () {return s && (t &&! i && (l = s.length-1, u.push (t)), function n (e) {E.each (e, function (e, t) {b ( т) r.unique && f.has (т) || s.push (т):! т && t.length && "строка" == Т (т) && п (т)})} (аргументы), т && && я с ()) , this}, remove: function () {return E.each (arguments, function (e, t) {var n; while (-1 <(n = E.inArray (t, s, n))) s.splice (n, 1), n ​​<= l && l -}), this}, имеет: function (e) {return e? -1 <E.inArray (e, s): 0 <s.length}, пусто: функция () {вернуть s && (s = []), это}, отключить: function () {вернуть a = u = [], s = t = "", это}, отключено: function () {return! s}, lock: function () {return a = u = [], t || i || (s = t = ""), this}, locked: function () {return !! a}, fireWith: function (e, t) {вернуть a || (t = [e, (t = t || []).slice? t.slice (): t], u.push (t), i || c ()), this}, fire: function () {вернуть f.fireWith (this, arguments), this}, сработало: function () {return !! o}}; return f}, E.extend ({Deferred: function (e) {var o = [["notify", "progress", E.Callbacks ("memory"), E .Callbacks («память»), 2], [«разрешить», «сделано», E.Callbacks («однажды память»), E.Callbacks («однажды память»), 0, «разрешено»], [»отклонить "," fail ", E.Callbacks (" однажды память "), E.Callbacks (" однажды память "), 1," отклонено "]], i =" в ожидании ", a = {state: function () {return i}, всегда: function () {return s.done (arguments) .fail (arguments), это}, «catch»: function (e) {return a.then (null, e)}, pipe: function () {var i = arguments; return E.Deferred (function (r) {E.each (o, function (e, t) {var n = b (i [t [4]]) && i [t [4]];s [t [1]] (function () {var e = n && n.apply (this, arguments); e && b (e.promise)? e.promise (). progress (r.notify) .done (r.resolve) .fail (r.reject): г [т [0] + "С"] (этого, н [е]: аргументы)})}), я = NULL}) обещание ()}, то:. функции ( t, n, r) {var u = 0; функция l (i, o, a, s) {return function () {var n = this, r = аргументы, e = function () {var e, t; если (! (i <u)) {if ((e = a.apply (n, r)) === o.promise ()) выбрасывает новый TypeError («возможное самостоятельное разрешение»); t = e && («объект "== typeof e ||" function "== typeof e) && e.then, b (t)? s? t.call (e, l (u, o, I, s), l (u, o, R , S)) :( у ++ t.call (е, л (и, о, I, S), л (и, о, R, S), л (и, о, я, o.notifyWith))) : (a! == I && (n = void 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? e: function () {try {e ()} catch (e) {E.Deferred.exceptionHook && E.Deferred.exceptionHook (e, t.stackTrace), u <= i + 1 && (a! == R && (n = void 0, r = [e]), о.rejectWith (n, r))}}; i? t () :( E.Deferred.getStackHook && (t.stackTrace = E.Deferred.getStackHook ()), g.setTimeout (t))}} return E.Deferred ( функция (е) {о [0] [3] .add (л (0, е, б (г) г: Я, e.notifyWith)), о [1] [3] .add (л (0, е, б (т) т: I)), о [2] [3] .add (л (0, е, б (п) п:?. Р))}) обещание ()}, обещание: функция (e) {return null! = e? E.extend (e, a): a}}, s = {}; вернуть E.each (o, function (e, t) {var n = t [2], г = т [5]; а [т [1]] = n.add, г && n.add (функция () {I = г}, о [3-е] [2] .disable, о [3-е] [3] .disable, о [0] [2] .lock, о [0] [3] .lock), n.add (т [3] .fire), S [T [0]] = функция () {return s [t [0] + "With"] (this === s? void 0: this, arguments), this}, s [t [0] + "With"] = n.fireWith}), a .promise (s), e && e.call (s, s), s}, когда: function (e) {var n = arguments.length, t = n, r = Array (t), i = s.call (arguments) ), o = E.Deferred (), a = function (t) {return function (e) {r [t] = this, i [t] = 1 <arguments.length? s.call (arguments): e, --n || о.resolveWith (г, я)}};.! если (п <= 1 && (В (е, o.done (а (т)) Решимость, o.reject, п), "до" === o.state ( ) || b (i [t] && i [t] .then))) return o.then (); в то время как (t -) B (i [t], a (t), o.reject); return o .promise ()}}); var M = / ^ (Eval | Внутренний | Диапазон | Ссылка | Синтаксис | Тип | URI) Ошибка $ /; E.Deferred.exceptionHook = function (e, t) {g.console && g.console .warn && e && M.test (e.name) && g.console.warn ("исключение jQuery.Deferred:" + e.message, e.stack, t)}, E.readyException = function (e) {g.setTimeout (function ( ) {throw e})}; var W = E.Deferred (); function F () {w.removeEventListener ("DOMContentLoaded", F), g.removeEventListener ("load", F), E.ready ()} E.fn.ready = function (e) {return W.then (e) ["catch"] (function (e) {E.readyException (e)}), this}, E.extend ({isReady:! 1 , readyWait: 1, готов: функция (е) {(0 === е - E.readyWait:? E.isReady) || (E.! IsReady = 0) == 0 && е <! - E.readyWait || W.resolveWith (ш, [Е])}}), E.ready.then = W.then, "полный" === w.readyState || "загрузка"! == w.readyState &&! w.documentElement.doScroll? g.setTimeout (E.ready) :( w.addEventListener ( "DOMContentLoaded", F), g.addEventListener ( "нагрузка", F)) ; var $ = функция (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ("object" === T (n )) для (s в i =! 0, n) $ (e, t, s, n [s] ,! 0, o, a), иначе if (void 0! == r && (i =! 0, b (r) || (a =! 0), l && (a? (t.call (e, r), t = null) :( l = t, t = function (e, t, n) {return l. ? вызова (е (е), п)})), т)) для (, s <и; s ++), т (е [с], п, а г: r.call (е [с], s, T (e [s], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, z = / ^ - ms - /, _ = / - ([az]) / g; функция U (e, t) {return t.toUpperCase ()} function V (e) {return e.replace (z, "ms -"). replace (_, U )} var X = function (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType};function Q () {this.expando = E.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: function (e) {var t = e [this.expando]; вернуть t || ( т = Object.create (нуль), X (е) && (e.nodeType е [this.expando] = т: Object.defineProperty (е, this.expando, {значение: т, конфигурируемый: 0})) ), t}, set: function (e, t, n) {var r, i = this.cache (e); if ("string" == typeof t) i [V (t)] = n; еще для (r in t) i [V (r)] = t [r]; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this. раскрыть] && e [this.expando] [V (t)]}, доступ: функция (e, t, n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [ this.expando]; if (void 0! == r) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map (V) :( t = V (t) )) в r? [t]: t.match (H) || []). length; в то время как (n -) delete r [t [n]]} (void 0 === t || E.isEmptyObject (г)) && (e.nodeType? е [это.expando] = void 0: удалить e [this.expando])}}, hasData: function (e) {var t = e [this.expando]; вернуть void 0! == t &&! E.isEmptyObject (t)}} ; var Y = новый Q, G = новый Q, K = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, J = / [ AZ] / g; функция Z (e, t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (J, "- $ &".) toLowerCase (), "строка" == TypeOf (п = e.getAttribute (г))) {попытка {п = "истина" === (я = п) || "ложь"! == я && ( "нулевой" === я нуль: я === + I + "" + I: K.test (я) JSON.parse (я): я)} поймать (е) {} G .set (e, t, n)} иначе n = void 0; вернуть n} E.extend ({hasData: function (e) {вернуть G.hasData (e) || Y.hasData (e)}, данные: function (e, t, n) {вернуть G.access (e, t, n)}, removeData: function (e, t) {G.remove (e, t)}, _ данные: функция (e, t, n ) {return Y.access (e, t, n)}, _ removeData: function (e, t) {Y.remove (e, t)}}), E.fn.extend ({data: function (n, e ) {var t, r, i, o = this [0],a = o && o.attributes; if (void 0 === n) {if (this.length && (i = G.get (o), 1 === o.nodeType &&! Y.get (o, "hasDataAttrs")) ) {т = a.length, в то время (т -) а [т] && 0 === (г = а [т] .name) .indexOf ( "данных -") && (г = V (r.slice ( 5)), Z (o, r, i [r])); Y.set (o, "hasDataAttrs",! 0)} return i} return "object" == typeof n? This.each (function () {G.set (this, n)}): $ (this, function (e) {var t; if (o && void 0 === e) вернуть void 0! == (t = G.get (o, n) )? t: void 0! == (t = Z (o, n))? t: void 0; this.each (function () {G.set (this, n, e)})}, null, e , 1 <arguments.length, null,! 0)}, removeData: function (e) {вернуть this.each (function () {G.remove (this, e)})}}), E.extend ({очередь : function (e, t, n) {var r; if (e) возвращает t = (t || "fx") + "queue", r = Y.get (e, t), n && (! r || Array.isArray (п) г = Y.access (е, т, E.makeArray (п)): r.push (п)), г || []}, Dequeue: функция (е, т) {т = т ||»fx "; var n = E.queue (e, t), r = n.length, i = n.shift (), o = E._queueHooks (e, t);" inprogress "=== i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), delete o.stop, i.call (e, function () {E.dequeue (e, t )}, o)),! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; вернуть Y.get (e, n) || Y.access (e , n, {empty: E.Callbacks ("однажды память"). add (function () {Y.remove (e, [t + "queue", n])})})}}), E.fn.extend ({queue: function (t, n) {var e = 2; вернуть "строку"! = typeof t && (n = t, t = "fx", e -), arguments.length <e? E.queue ( this [0], t): void 0 === n? this: this.each (function () {var e = E.queue (this, t, n); E._queueHooks (this, t), "fx "=== t &&" inprogress "! == e [0] && E.dequeue (this, t)})}, dequeue: function (e) {вернуть this.each (function () {E.dequeue (this, e)})}, clearQueue: function (e) {вернуть this.queue (e || "fx", [])}, обещание: function (e, t) {var n, r = 1, i = E.Deferred (), o = this, a = this.length, s = function () {- r || i.resolveWith (o, [o])}; "строка"! = typeof e && (t = e, e = void 0), e = e || "fx"; while (a -) (n = Y.get (o [a], e + "queueHooks")) && n.empty && (r ++, n. empty.add (s)); вернуть s (), i.promise (t)}}); var ee = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, te = new RegExp ("^ (?: ([+ -]) = |) (" + ee + ") ([az%] *) $", "i "), ne = [" Top "," Right "," Bottom "," Left "], re = w.documentElement, т.е. = function (e) {return E.contains (e.ownerDocument, e)}, oe = {составе:! 0}; re.getRootNode && (то есть = функция (е) {вернуть E.contains (e.ownerDocument, е) || e.getRootNode (oe) === e.ownerDocument}); функция (е, т) {возвращение «нет»=== (е = т || е) .style.display || "" === e.style.display && т.е. (е) && "нет" === E.css (е, "дисплей")}; вар se = {}; функция ue (e, t) {for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c <f; c ++ ) (г = е [с]). стиль && (п = r.style.display, т? ( "нет" === п && (л [с] = Y.get (г, "дисплей") || нуль, l [c] || (r.style.display = "")), "" === r.style.display && ae (r) && (l [c] = (u = a = o = void 0, a = (я = г) .ownerDocument, с = i.nodeName, (и = се [с]) || (о = a.body.appendChild (a.createElement (ы)), и = E.css (о,» дисплей "), o.parentNode.removeChild (о)," нет "=== у && (и =" блок "), се [с] = и)))):" ни один "== п && (л [с ] = "нет", Y.set (г, "дисплей", п))), для (с = 0; с <е;! C ++) нуль = л [с] && (е [с] .style.display = l [c]); return e} E.fn.extend ({show: function () {return ue (this ,!0)}, hide: function () {return ue (this)}, toggle: function (e) {return "boolean" == typeof e? E? This.show (): this.hide (): this.each (function () {ae (this)? E (this) .show (): E (this) .hide ()})}}); var le, ce, fe = / ^ (?: checkbox | radio) $ / я, де = / <([AZ] [^ \ / \ 0> \ x20 \ т \ г \ п \ е] *) / я, ре = / ^ $ | ^ модуль $ | \ / (?: ява | ECMA) скрипт / я;. ль = w.createDocumentFragment (.) AppendChild (w.createElement ( "ДИВ")), (с = w.createElement ( "вход")) SetAttribute ( "тип", "радио") , ce.setAttribute ( "проверено", "проверено"), ce.setAttribute ( "имя", "т"), le.appendChild (в.п.), m.checkClone = le.cloneNode (! 0) .cloneNode (! 0 ) .lastChild.checked, le.innerHTML = "<TextArea> х </ TextArea>", m.noCloneChecked = !! le.cloneNode (! 0) .lastChild.defaultValue, le.innerHTML = "<опция> </ опция >», m.option = !! le.lastChild;var he = {thead: [1, "<table>", "</ table>"], col: [2, "<table> <colgroup>", "</ colgroup> </ table>"], tr : [2, "<таблица> <TBODY>", "</ TBODY> </ таблицы>"], тд: [3, "<таблица> <TBODY> <TR>", "</ TR> </ TBODY > </ table> "], _ default: [0," "," "]}; функция ge (e, t) {var n; return n =" undefined "! = typeof e.getElementsByTagName? e.getElementsByTagName (t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t || t && S (e, t)? E.merge ([e], n): n} функция ve (e, t) {for (var n = 0, r = e.length; n <r; n ++) Y.set (e [n], "globalEval", ! т || Y.get (т [п], "globalEval"))} he.tbody = he.tfoot = he.colgroup = he.caption = he.thead, he.th = he.td, м.option || (he.optgroup = he.option = [1, "<выберите несколько = 'несколько'>", "</ select>"]); функция var ye = / <| & #? \ w +; /; функция me (e, t, n, r, i) {для (var o, a, s, u, l, c, f = t.createDocumentFragment (), d = [], p = 0, h = e.length ; р <ч;? р ++), если ((о = е [р]) || 0 === о), если ( "объект" === Т (о)) E.merge (д, o.nodeType [о ]: o); иначе if (ye.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), и = он [с] || he._default, a.innerHTML = и [1] + E.htmlPrefilter (о) + и [2], с = U [0 ]; while (c -) a = a.lastChild; E.merge (d, a.childNodes), (a = f.firstChild) .textContent = ""} else d.push (t.createTextNode (o)) ; f.textContent = "", p = 0; while (o = d [p ++]) if (r && - 1 <E.inArray (o, r)) i && i.push (o); иначе if (l = ie ( о), а = GE (f.appendChild (о), "сценарий"), л && ве (а), п) {с = 0, в то время (о = [C ++]) pe.test (о.тип || "") && n.push (o)} return f} var be = / ^ key /, xe = / ^ (?: мышь | указатель | contextmenu | drag | drop) | click /, we = / ^ ( [^.] *) (?: \. (. +) |) /; function Ce () {return! 0} function Te () {return! 1} функция Ee (e, t) {return e === function () {try {return w.activeElement} catch (e) {}} () == ("focus" === t)} function Ae (e, t, n, r, i, o) {var a , s; if ("объект" == typeof t) {for (s в "string"! = typeof n && (r = r || n, n = void 0), t) Ae (e, s, n, r , t [s], o); вернуть e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)) ,! 1 === i) i = Te; иначе if (! i) вернуть e; вернуть 1 === o && (a = i, (i = function (e) {вернуть E (). off (e), a.apply (this, аргументы)}). guid = a.guid || (a.guid = E.guid ++ )), e.each (function () {E.event.add (this, t, i, r, n)})} функция Ne (e, i, o) {o? (Y.set (e, i , 1), E.event.add (е, я, {имен:! 1, обработчик:function (e) {var t, n, r = Y.get (this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (E.event.special [i] || {} ) .delegateType && e.stopPropagation (); иначе, если (r = s.call (аргументы), Y.set (this, i, r), t = o (this, i), this [i] (), r! = = (n = Y.get (this, i)) || t? Y.set (this, i,! 1): n = {}, r! == n) return e.stopImmediatePropagation (), e.preventDefault (), n.value} else r.length && (Y.set (this, i, {value: E.event.trigger (E.extend (r [0], E.Event.prototype), r.slice (1) ), это)}), e.stopImmediatePropagation ())}})): void 0 === Y.get (e, i) && E.event.add (e, i, Ce)} E.event = {global : {}, add: function (t, e, n, r, i) {var o, a, s, u, l, c, f, d, p, h, g, v = Y.get (t) ; если (Х (т)) {n.handler && (п = (о = п) .handler, I = o.selector), я && E.find.matchesSelector (п, я), n.guid || (n.guid = E.guid ++), (и = v.events) || (и = v.events = Object.create (нуль)), (а = v.handle) || (а = v.handle = функция (е) {возвращение «неопределенное»!= typeof E && E.event.triggered! == e.type? E.event.dispatch.apply (t, arguments): void 0}), l = (e = (e || ""). match (H) | | [ ""].) длина; при этом (л -) р = г = (s = we.exec (е [л]) || []) [1], ч = (с [2] ||» ") .split (" ") рода (), р && (е = E.event.special [р] || {}, р = (я f.delegateType:..? f.bindType) || P, F = E.event.special [р] || {}, с = E.extend ({тип: р, OrigType: г, данные: г, обработчик: п, справ: n.guid, селектор: я, needsContext: я && Е. expr.match.needsContext.test (я), пространство имен:. h.join ( "")}, о), (д = и [р]) || ((д = и [р] = []) delegateCount = 0, f.setup &&! 1! == f.setup.call (т, г, д, а) || t.addEventListener && t.addEventListener (р, а)), f.add && (f.add.call (т , с), c.handler.guid || (c.handler.guid = n.guid)), я d.splice (d.delegateCount ++ 0, с): d.push (с), E.event. global [p] =! 0)}}, remove: function (e, t, n, r, i) {var o, a, s, u, l, c, f, d, p, h, g, v = Y.hasData (е) && Y.получаем (е), если (V && (и = v.events)) {л = (т = (т || "") совпадают (Н) ||. [ ""]) длина;., а (L--) если (р = г = (s = we.exec (т [л]) || []) [1], H = (с [2] || ""). сплит ( ""). рода () , р) {е = E.event.special [р] || {}, д = и [р = (г f.delegateType: f.bindType) || р] || [], s = s [2 ] && new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + "(\\. | $)"), a = o = D.Length, в то время (о -) с = д [о] ,! я && г == c.origType || п && n.guid == c.guid || s && s.test (c.namespace) ||!!! ! г && г == c.selector && ( "**" == г || c.selector!) || (d.splice (о, 1), c.selector && d.delegateCount -, f.remove && f.remove.call (е, с));! && && D.Length (f.teardown && 1 == f.teardown.call (е, ч, v.handle!!) || E.removeEvent (е, р, v.handle), удалить u [p])} else для (p in u) E.event.remove (e, p + t [l], n, r,! 0); E.isEmptyObject (u) && Y.remove (e, "обрабатывать события ")}}, диспетчеризация: функция (e) {var t, n, r, i, o, a, s = новый массив (arguments.length), u = E.event.fix (e), l = (Y.get (это, "события") || Object.create (нуль)) [u.type] || [], с = E.event.special [u.type] || {}; для (S [0] = и, т = 1, т <arguments.length; т ++) s [т] = аргументы [т];!! если (u.delegateTarget = это, c.preDispatch || 1 == c.preDispatch .call (это, и)) {а = E.event.handlers.call (это, U, L), т = 0, тогда как ((я = а [T ++]) && u.isPropagationStopped ()) {и! .currentTarget = i.elem, п = 0;!!! в то время как (! (о = i.handlers [п ++]) && u.isImmediatePropagationStopped ()) u.rnamespace && 1 == o.namespace && u.rnamespace.test (о .namespace) || (u.handleObj = o, u.data = o.data, void 0! == (r = ((E.event.special [o.origType] || {}). дескриптор || o .handler) .apply (i.elem, s)) &&! 1 === (u.result = r) && (u.preventDefault (), u.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (это, и), и.результат}}, обработчики: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click "=== e.type && 1 <= e.button)) для (;! л == это, л = l.parentNode || это), если (1 === l.nodeType && (" нажмите "== е!. тип ||! 0! == l.disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [ n]). selector + ""] && (a [i] = r.needsContext? -1 <E (i, this) .index (l): E.find (i, this, null, [l]). length ), a [i] && o.push (r); o.length && s.push ({elem: l, handlers: o})} return l = this, u <t.length && s.push ({elem: l, handlers: t.slice (и)}), с}, addProp: функция (т, е) {Object.defineProperty (E.Event.prototype, т, {перечислимы: 0, конфигурируемый: 0, получим: б (е) ? function () {if (this.originalEvent) вернуть e (this.originalEvent)}: function () {if (this.originalEvent) вернуть this.originalEvent [t]}, установить: function (e) {Object.defineProperty ( этот,t, {enumerable:! 0, настраиваемый:! 0, доступный для записи:! 0, значение: e})}})}, fix: function (e) {return e [E.expando]? e: new E.Event ( e)}, special: {load: {noBubble:! 0}, щелкните: {setup: function (e) {var t = this || e; вернуть fe.test (t.type) && t.click && S (t, " input ") && Ne (t," click ", Ce) ,! 1}, триггер: function (e) {var t = this || e; вернуть fe.test (t.type) && t.click && S (t," input ") && Ne (t," click ") ,! 0}, _ по умолчанию: function (e) {var t = e.target; вернуть fe.test (t.type) && t.click && S (t," input ") && Y. get (t, "click") || S (t, "a")}}, перед загрузкой: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e. результат)}}}}, E.removeEvent = функция (е, т, п) {e.removeEventListener && e.removeEventListener (т, п)}, E.Event = функция (е, т) {если (!(этот экземпляр E.Event)) возвращает новый E.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 = == e.defaultPrevented && 1 === e.returnValue Ce:? Те, this.target = e.target && 3 === e.target.nodeType e.target.parentNode: e.target, this.currentTarget = е. currentTarget, this.relatedTarget = e.relatedTarget): this.type = е, т && E.extend (это, т), this.timeStamp = е && e.timeStamp || Date.now (), это [E.expando] = 0 }, E.Event. , e &&! this.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ce, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ce, e &&! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()} alK {) {eey ( : 0, пузыри: 0, отменяемый: 0, changedTouches: 0, ctrlKey: 0, деталь: 0, EventPhase: 0, metaKey: 0, pageX: 0, Пейджи: 0, shiftKey : 0, вид: 0, "символ": 0, код: 0, charCode: 0, ключ: 0, KEYCODE: 0, кнопка: 0, кнопки: 0, clientX: 0 , clientY: 0, OffsetX: 0, OffsetY: 0, pointerId: 0, pointerType: 0, ScreenX: 0, Screeny: 0, targetTouches: 0, toElement: 0, прикосновений: 0 , который: function (e) {var t = e.button; вернуть null == e.which && be.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0 ! == т && xe.test (e.type) 1 & т 1:? 2 & т 3:? 4 & т 2: 0: e.which}}, E.event.addProp), E.each ({фокус: "focusin", размытие:»focusout "}, function (e, t) {E.event.special [e] = {setup: function () {return Ne (this, e, Ee) ,! 1}, триггер: function () {return Ne ( это, е) ,! 0}, delegateType: т}}), E.each ({MouseEnter: "Mouseover", MouseLeave: "MouseOut", pointerenter: "pointerover", pointerleave: "pointerout"}, функция (е, i) {E.event.special [e] = {DelegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObj; вернуть n && (n ===) это || E.contains (это, п)) || (e.type = r.origType, т = r.handler.apply (это, аргументы), e.type = я), т}}}), Е .fn.extend ({on: function (e, t, n, r) {return Ae (this, e, t, n, r)}, one: function (e, t, n, r) {return Ae ( this, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, E (e.delegateTarget) ) .off (r.namespace r.origType + + r.namespace? "": r.origType, r.selector, r.handler), это;if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); вернуть this} return! 1! == t && "function"! = typeof t || (n = t, t = void 0) ,! 1 === n && (n = Te), this.each (function () {E.event.remove (this, e, n, t)})}}) ; var Se = / <script | <style | <link / i, ke = / checked \ s * (?: [^ =] | = \ s * .checked.) / i, De = / ^ \ s * < ! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; функция Le (e, t) {return S (e, "table") && S (11! == t.nodeType? T: t.firstChild, "tr") && E (e) .children ("tbody") [0] || e} функция je (e) {return e.type = ( null! == e.getAttribute ("type")) + "/" + e.type, e} функция qe (e) {return "true /" === (e.type || ""). slice ( 0,5)? E.type = e.type.slice (5): e.removeAttribute ("type"), e} function Oe (e, t) {var n, r, i, o, a, s; if (1 === t.nodeType) {if (Y.hasData (e) && (s = Y.get (e) .events)) для (i в Y.remove (t, "обрабатывать события "), s) для (n = 0, r = s [i]. длина; n <r; n ++) E.event.add (t, i, s [i] [n]); G.hasData (e) && (o = G.access (e), a = E.extend ({}, o), G.set (t, a))}} функция Pe (n, r, i, o) {r = v (r); var e, t, a, s, u, l, c = 0, f = длина n, d = f-1, p = r [0], h = b (p), если (h || 1 <f && "string" == typeof p &&! m.checkClone && ke.test (p)) return n.each (function (e) {var t = n.eq (e); h && (r [0]) = p.call (это, е, t.html ())), Ре (т, т, I, O)}); если (е && (т = (е = я (г, п [0] .ownerDocument, ! 1, N, O)). FirstChild, 1 === e.childNodes.length && (е = т), т || о)) {для (с = (а = E.map (GE (е, "сценарий «), JE)) длина;. с <е;!!! C ++) и = E, C == d && (U = E.clone (и, 0, 0), S && E.merge (а, GE (и, "сценарий"))), i.call (п [с], и, с); если (ы) для (л = а [a.length-1] .ownerDocument, E.map (а, QE), с = 0; с <с; C ++) и = а [C], pe.test (u.type || "") && Y.access (и,! "globalEval") && E.содержит (л, и) && (u.src && "модуль" == (u.type || "") toLowerCase () E._evalUrl && && u.noModule E._evalUrl (u.src, {случайное слово:!.?! и. nonce || u.getAttribute ("nonce")}, l): C (u.textContent.replace (De, ""), u, l))} return n} функция He (e, t, n) {для (var r, i = t? E.filter (t, e): e, o = 0; null! = (r = i [o]); o ++) n || 1! == r.nodeType || E .cleanData (ge (r)), r.parentNode && (n && ie (r) && ve (ge (r, "script")), r.parentNode.removeChild (r)); вернуть e} E.extend ({htmlPrefilter: function (e) {return e}, clone: ​​function (e, t, n) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = т.е. (e) ; если (!!! (m.noCloneChecked || 1 == e.nodeType && 11 == e.nodeType || E.isXMLDoc (е))) для (а = GE (с), г = 0, I = (о = ge (e)). length; r <i; r ++) s = o [r], u = a [r], void 0, "input" === (l = u.nodeName.toLowerCase ()) && fe .test (s.type) u.checked = s.checked: "вход"! == л && "TextArea" == л || (u.defaultValue = s.defaultValue); если (т), если (п) при (о = о || GE (е), а = || Ge ( c), r = 0, i = o.length; r <i; r ++) Oe (o [r], a [r]), иначе Oe (e, c); вернуть 0 <(a = ge (c, "script")). length && ve (a,! f && ge (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = E.event.special, o = 0; void 0! == (n = e [o]); o ++) if (X (n)) {if (t = n [Y.expando]) {if (t.events) для (r в t. события) i [r]? E.event.remove (n, r): E.removeEvent (n, r, t.handle); n [Y.expando] = void 0} n [G.expando] && (n [G.expando] = void 0)}}}), E.fn.extend ({detach: function (e) {return He (this, e,! 0)}, remove: function (e) {return He ( this, e)}, text: function (e) {return $ (this, function (e) {return void 0 === e? E.text (this): this.empty (). each (function () { 1 == this.nodeType && 11 == this.nodeType && 9 == this.nodeType || (this.textContent = е)})}, нуль, е, arguments.length)}, Append!!!:function () {return Pe (this, arguments, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Le (this, e) .appendChild (e)}) }, prepend: function () {return Pe (this, arguments, function (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Le (this, e); t.insertBefore (e, t.firstChild)}})}, before: function () {return Pe (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore ( e, this)})}, после: function () {return Pe (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, пусто: function () { for (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (E.cleanData (ge (e,! 1)), e.textContent = "" ); return this}, clone: ​​function (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return E.clone (this, e , t)})}, html: function (e) {return $ (this,function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) возвращает t.innerHTML; if (" строка "== typeof e &&! Se.test (e) &&! he [(de.exec (e) || [" "," "]) [1] .toLowerCase ()]) {e = E.htmlPrefilter ( е); попытка {для (; п <г;.! п ++), 1 === (т = это [п] || {}) NODETYPE && (E.cleanData (GE (т, 1)), t.innerHTML = e); t = 0} catch (e) {}} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var n = []; вернуть Pe (this, arguments, function (e) {var t = this.parentNode; E.inArray (this, n) <0 && (E.cleanData (ge (this)), t && t.replaceChild (e, this))}, n )}}), E.each ({appendTo: "Append", prependTo: "перед именем", InsertBefore: "перед", InsertAfter: "после", replaceAll: "ReplaceWith"}, функция (е, а) {Е. fn [e] = функция (e) {для (var t, n = [], r = E (e), i = r.length-1, o = 0; o <= i;o ++) t = o === i? this: this.clone (! 0), E (r [o]) [a] (t), u.apply (n, t.get ()); вернуть это. pushStack (n)}}); var Ie = new RegExp ("^ (" + ee + ") (?! px) [az%] + $", "i"), Re = функция (e) {var t = e.ownerDocument.defaultView; вернуть t && t.opener || (t = g), t.getComputedStyle (e)}, Be = function (e, t, n) {var r, i, o = {}; для (i в t) o [i] = e.style [i], e.style [i] = t [i]; для (i в r = n.call (e), t) e.style [i] = o [i]; return r}, Me = new RegExp (ne.join ("|"), "i"); функция We (e, t, n) {var r, i, o, a, s = e. стиль, возврат (п = п || Re (е)) && ( "" == (а = n.getPropertyValue (т) || п [т]) || т (е) || (а = е!. стиль (е, т)) ,! m.pixelBoxStyles () && Ie.test (а) && Me.test (т) && (г = s.width, I = s.minWidth, о = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} функция Fe (е, т) {возвращение {получаем: функция () {если (!e ()) return (this.get = t) .apply (this, аргументы); удалить this.get}}}! function () {function e () {if (l) {u.style.cssText = "position : абсолютный; слева: -11111px, ширина: 60px; Верхнее поле: 1px; обивка: 0; границы: 0" , l.style.cssText = "положение: относительный; дисплей: блок; коробчатых размеры: границы коробка; переполнение: прокрутка; маржа: авто; граница: 1 пиксель; отступ: 1 пиксель; ширина: 60%; верх: 1% ", re.appendChild (u) .appendChild (l); var e = g.getComputedStyle (l); n = "1%"! == e.top, с = 12 === т (e.marginLeft), l.style.right = "60%", о = 36 === т (e.right), г = 36 === т (e.width), l.style.position = "абсолютный", I = 12 === т (l.offsetWidth / 3), re.removeChild (и), л = NULL}} функция t (e) {return Math.round (parseFloat (e))} var n, r, i, o, a, s, u = w.createElement ("div"), l = w.createElement0) +1)}, teardown: function () {var e = this.ownerDocument || this.document || this, t = Y. доступ (e, r) -1; t? Y. доступ (e, r , t) :( e.removeEventListener (n, i,! 0), Y.remove (e, r))}}}), E.parseXML = function (e) {var t; if (! e || " строка "! = typeof e) return null; try {t = (new g.DOMParser) .parseFromString (e," text / xml ")} catch (e) {t = void 0} return t &&! t.getElementsByTagName (" parsererror "). length || E.error (" Неверный XML: "+ e), t}; var ft, dt = / \ [\] $ /, pt = / \ r? \ n / g, ht = / ^ (?: отправить | кнопка | изображение | сбросить | файл) $ / i, gt = / ^ (?: input | select | textarea | keygen) / i; функция vt (n, e, r, i) {var t ; если (Array.isArray (е)) E.each (е, функция (е, т) {г || dt.test (п) я (п, т): VT (п + "[" + ( "объект "== typeof t && null! = t? e:" ") +"] ", t, r, i)}); иначе if (r ||" object "! == T (e)) i (n, e ), иначе для (t в e) vt (n + "[" + t + "]", e [t], r, i)} E.param = function (e, t) {var n, r = [], i = function (e, t) {var n = b (t)? t (): t; r [r.length] = encodeURIComponent (e ) + "=" + encodeURIComponent (нуль == п "?": п)}, если (нуль == е) возвращение ""; если (Array.isArray (е)! || e.jquery && E.isPlainObject (е )) E.each (e, function () {i (this.name, this.value)}); еще для (n в e) vt (n, e [n], t, i); вернуть r.join ("&")}, E.fn.extend ({serialize: function () {return E.param (this.serializeArray ())}, serializeArray: function () {вернуть this.map (function () {var e = E.prop (this, "elements"); вернуть e? E.makeArray (e): this}). Filter (function () {var e = this.type; вернуть this.name &&! E (this) .is ( ": отключение"!). && gt.test (this.nodeName) && ht.test (е) && (! this.checked || fe.test (е))}) карта (функция (е, т) {вар n = E (this) .val (); return null == n? null: Array.isArray (n)? E.map (n, function (e) {return {name: t.name, value:e.replace (пт, "\ г \ п")}}): {имя: t.name, значение:. n.replace (пт, "\ г \ п")}}) получаем ()}}), E.fn.extend ({wrapAll: function (e) {var t; вернуть this [0] && (b (e) && (e = e.call (this [0])), t = E (e, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e. firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (n) {return b (n)? this.each (function (e) {E (this) .wrapInner (n.call (this, e))}): this.each (function () {var e = E (this), t = e.contents (); t.length? t.wrapAll (n): e. append (n)})}, wrap: function (t) {var n = b (t); вернуть this.each (function (e) {E (this) .wrapAll (n? t.call (this, e) : t)})}, развернуть: function (e) {вернуть this.parent (e) .not ("body"). each (function () {E (this) .replaceWith (this.childNodes)}), это }}), E.expr.pseudos.hidden = функция (е) {возвращение! E.expr.pseudos.видимые (е)}, E.expr.pseudos.visible = функция (е) {возвращение !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). длина)}, m.createHTMLDocument = ((футы = w.implementation.createHTMLDocument ( ""). тела) .innerHTML = "<форма> </ форма> <форма> </ форма>", 2 === ft.childNodes.length), E.parseHTML = функция ( e, t, n) {вернуть "строку"! = typeof e? [] :( "boolean" == typeof t && (n = t, t =! 1), t || (m.createHTMLDocument? ((r = (т = w.implementation.createHTMLDocument ( "")) createElement. ( "база")) = HREF w.location.href, t.head.appendChild (г)):.! т = ш), о = п && [ ], (I = k.exec (е))? [t.createElement (я [1])] :( I = я ([е], т, о), о && && o.length е (о) .remove (), E.merge ([], i.childNodes))); var r, i, o}, E.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u , л = E.css (е, "положение"), с = е (е), F = {}; "статический" === л && (е.style.position = "относительно"), с = c.offset (), о = E.css (е, "верхний"), и = E.css (е, "влево"), ( "абсолютный" === . || л "фиксированный" === л) && - 1 <(? о + и) .indexOf ( "авто") (а = (г = c.position ()) сверху, я = r.left): (а = parseFloat (о) || 0, I = parseFloat (и) || 0), б (т) && (т = t.call (е, п, E.extend ({}, S))), null! = t.top && (f.top = t.top-s.top + a), null! = t.left && (f.left = t.left-s.left + i), «используя» в t? t.using.call (e, f) :( "число" == typeof f.top && (f.top + = "px"), "number" == typeof f.left && (f.left + = "px"), c.css (f))}}, E.fn.extend ({offset: function (t) {if (arguments.length) return void 0 === t? this: this.each (function (e) {E) .offset.setOffset (this, t, e)}); var e, n, r = this [0]; return r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r. ownerDocument.defaultView, {верх: e.top + п.pageYOffset, слева: e.left + n.pageXOffset}): {top: 0, left: 0}: void 0}, position: function () {if (this [0]) {var e, t, n, r = это [0], I = {верх: 0, слева: 0}, если ( "фиксированные" === E.css (г, "позиция")) т = r.getBoundingClientRect (); еще {т = это .offset (), п = r.ownerDocument, е = r.offsetParent || n.documentElement, в то время (е && (е === n.body || е === n.documentElement) && "статический" === E.css (е, "позиция")) е = e.parentNode;!. е && е == г && 1 === e.nodeType && ((я = е (е) .offset ()) верхняя часть + = E.css (е, "borderTopWidth", 0), i.left + = E.css (е, "borderLeftWidth", 0))} {возвращение верхней части:! t.top-i.top-E.css (г, "MarginTop" ,! 0), слева: t.left-i.left-E.css (r, "marginLeft",! 0)}}}, offsetParent: function () {вернуть this.map (function () {var e = this. offsetParent, в то время (е && "статических" === E.css (е, "позиция")) е = e.offsetParent;return e || re})}}), E.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, функция (t, i) {var o = "pageYOffset" === i; E.fn [t] = function (e) {return $ (this, function (e, t, n) {var r; if (x (e)? r = e: 9 === e.nodeType && (r = e.defaultView ), void 0 === n) return r? r [i]: e [t]; r? r.scrollTo (o? r.pageXOffset: n, o? n: r.pageYOffset): e [t] = п}, т, е, arguments.length)}}), E.each ([ "верх", "влево"], функция (е, п) {E.cssHooks [п] = Ре (m.pixelPosition, функция (e, t) {if (t) вернет t = We (e, n), то есть .test (t)? E (e) .position () [n] + "px": t})}), E .each ({высота: "высота", ширина: "ширина"}, функция (a, s) {E.each ({обивка: "внутренний" + а, содержание: s "": "внешний" + а} , function (r, o) {E.fn [o] = function (e, t) {var n = arguments.length && (r || "boolean"! = typeof e), i = r || (! 0 = ! == е || 0 === т "запас": "граница");?return $ (this, function (e, t, n) {var r; return x (e)? 0 === o.indexOf ("external")? e ["inner" + a]: e.document.documentElement [ "клиент" + а]: 9 === e.nodeType (г = e.documentElement, Math.max (e.body [ "прокрутки" + а], г [ "прокрутки" + а], e.body ["offset" + a], r ["offset" + a], r ["client" + a])): void 0 === n? E.css (e, t, i): E.style ( e, t, n, i)}, s, n? e: void 0, n)}})}), E.fn.extend ({bind: function (e, t, n) {вернуть this.on ( e, null, t, n)}, unbind: function (e, t) {вернуть this.off (e, null, t)}, делегат: function (e, t, n, r) {вернуть this.on ( t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length? this.off (e, "**"): this.off (t, e | | "**", n)}, hover: function (e, t) {вернуть this.mouseenter (e) .mouseleave (t || e)}}), E.each ("размытие, фокус, фокусировка, фокусировка, изменение размера, прокрутка, щелчок dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave изменить выбрать отправить отправить нажатие клавиши {return 0 <arguments.length? this.on (n, null, e, t): this.trigger (n)}}); var yt = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; E.proxy = function (e, t) {var n, r, i; if ("строка" == typeof t && (n = e [t], t = e, e = n), b (e)) return r = s.call (arguments, 2), (i = function () {return e.apply (t || this, r.concat (s.call (arguments)))} ) .guid = e.guid = e.guid || E.guid ++, я}, E.holdReady = функция (е) {е E.readyWait ++?! E.ready (0)}, E.isArray = массив. IsArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = Ь, E.isWindow = х, E.camelCase = В, E.type = Т, E.now = Date.now, Е. isNumeric = function (e) {var t = E.type (e); return ("число" === t || "строка" === t) &&! isNaN (e-parseFloat (e))}, E.trim = function (e) {return null == e? "" :( e + ""). replace (yt, "")}, "function" = = typeof define && define.amd && define ("jquery", [], function () {return E}); var mt = g.jQuery, bt = g. $; return E.noConflict = function (e) {return g. $ = == E && (g. $ = Bt), e && g.jQuery === E && (g.jQuery = mt), E}, "undefined" == typeof e && (g.jQuery = g. $ = E), E} );JQuery = г $ = Е), Е}).JQuery = г $ = Е), Е}).